1.文件描述符必须设置为非阻塞的，否则程序会阻塞在accept处，导致程序接受不到已接受的文件描述符已准备好信息
2.直接调用rio_readn出错？当直接调用read时，程序功能正常 ，原因如下:
   if (errno == EINTR) 
                nread = 0;      // and call read() again 
   else if((errno == EAGAIN) ||(errno == EWOULDBLOCK)) //最开始没有对这两个错误量进行判断，导致直接return -1,而实际上，有可能已读取完毕，返回的是-1
   {
       break;
   }
   else
   {
      debug_info("rio_readn");
      return -1;      // errno set by read()  
   }

3.使用内存数据留解析数据
4.string 的长度不包括结尾的/n?会包括结尾的/n,但是不包括/0
5.应该从配置文件中读取文件根目录
6.构建响应文件，包括响应行，响应头部，响应实体     //头部处理函数应该作为回调函数，方便扩展（首先添加必要的头部，然后根据需求生成要求的头部，要求的头
  部，以及相对应的回调函数放在一个数组中）

7.为什么delete 一个字符数组会出错（coredump 地址不合法？）这个问题没有解决，是有关动态内存分配与释放的问题。(换了一种方式来实现功能)
  //问题原因：
    通过string  c_str返回的是指向c风格字符串的指针，而不是内容。
     引起错误的做法是，cha*usr_buf ; usr_buf = new char[222];  usr_buf = string.c_str(); 在这里，usr_buf的地址已经不是指向动态分配的内存了。
    所以再次调用delete会引起错误。因为传入的指针并不是由new开辟出来的。
8. 搞清楚http的keep-alive（keep-alive 在服务器端是如何实现的?）
    /*
    if (n == 0) {   
            // EOF
            log_info("read return 0, ready to close fd %d, remain_size = %zu", fd, remain_size);
            goto err;
        }

        if (n < 0) {
            if (errno != EAGAIN) {
                log_err("read err, and errno = %d", errno);
                goto err;
            }
            break;
        }
      */      不明白这里

//  测试出问题。。。。？？ 为什么后续的请求不响应了？(这个问题应该是epoll eventshot 出问题了)现在是找不到出错的地方。。。。。。
     //通过更改源码，现在问题重现。
     //现在有一个地方的问题是由于响应头部造成的:Content-Length (浏览器一直接受不到响应的其中一个原因就是没有Content-Length这个字段)
//设置响应头的回调函数应该重新设计，现在的扩展性不够好。
//现在出现的另发送文件总是存在阻塞的情况。。。。不知到如何解决。。。。（浏览器对其中一个发送的响应一直不响应）
//程序出现bug，发送的头部里是乱码 
 以上问题解决办法是:将响应行与响应头部一起发送给客户端。
 （增加错误处理方法）而且最后发送的一直都是EAGAIN,RIO_Read 的返回码没有理解。。。
   是这样的：由于rio_read 在EOF和EAGAIN时都会返回0，而erron一直保存的是上一次的EAGAIN的值，所以在这里出错了，导致本是EOF也误判成了EAGAIN，导致无法关闭文件描述符。所以每次调用rio_read之前都要初始化errno。


//动态内容会包含会包含一个?,以这个?作为是否是动态服务的准则

//增加线程池，提共并发能力（线程池是否考虑设计为单列模式呢）
//    如何让线程池与httpRequest类型捷耦合

//为什么pthread_cond_signal是出错，但是其他线程也确实因为他而被唤醒了（这里并没有出错）
//远端机测试的时候，为什么有的响应内容无法送出去呢？？？？


//线程池销毁过程:
        1.检测池子状态，是否已经销毁
	2.获得互斥锁，防止其他线程修改该线程池
        3.将线程池的状态修改为stop
        4.广播通知所有线程
        5.释放互斥锁
        6.调用pthread_join 回收线线程资源
        7.销毁互斥锁，条件锁
        8.销毁动态分配的资源

//线程池完工。
//下一步，压力测试。 了解内存池。加上fastCGI(这一步暂时不做，貌似与php有关)

//直接使用系统的new ,delete 的缺点：
        在内存空闲块表中查找一块空闲内存，调用free/delete,系统可能需要合并空闲内存块，这些会产生额外开销（具体是什么开销）
        频繁使用时会产生大量内存碎片，从而降低程序运行效率
        容易造成内存泄漏

       内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，
       首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：

       比malloc/free进行内存申请/释放的方式快
       不会产生或很少产生堆碎片
       可避免内存泄漏
// 不实现内存池，fastCGI

//把timer实现以及压力测试做完就行了，没时间了。。。

//strace的使用,线程调试工具，它能够显示所有由用户空间程序发出的系统调用。调试工具 strace
//了解linux下的调试工具


